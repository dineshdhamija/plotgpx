<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPX Multi-Compare · Time & Distance</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { --gap: 16px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 24px; background:#0b0c10; color:#eaf0f6; }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { font-size: clamp(18px, 2vw, 24px); margin: 0 0 12px; }
    .card { background: #111319; border: 1px solid #1e2230; border-radius: 16px; padding: clamp(12px, 2vw, 16px); box-shadow: 0 8px 32px rgba(0,0,0,0.24); }

    .controls { display: grid; grid-template-columns: 1fr; gap: var(--gap); align-items: start; margin-bottom: var(--gap); }
    @media (min-width: 720px) { .controls { grid-template-columns: 2fr 1fr 1fr; } }

    .group { display: grid; gap: 6px; }
    label { font-size: 12px; color: #9fb3c8; }
    input[type="file"], input[type="number"] { padding: 8px; background: #0f1220; border: 1px solid #2a3550; border-radius: 10px; color:#cfe3ff; }
    input[type="number"] { width: 100%; }

    .row { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    @media (min-width: 860px) { .row { grid-template-columns: 1fr 1fr; } }

    /* Fix: give charts a fixed-height wrapper to avoid resize loops */
    .chartWrap { position: relative; height: 320px; width: 100%; }
    @media (min-width: 860px) { .chartWrap { height: 420px; } }
    canvas { background: #0f1220; border-radius: 12px; padding: 8px; display:block; width:100% !important; height:100% !important; }

    .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { background:#3b82f6; color:white; border:none; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .small { font-size: 12px; }

    .meta { display:grid; gap:8px; grid-template-columns: 1fr; margin: 6px 0 10px; }
    @media (min-width: 720px) { .meta { grid-template-columns: 1fr 1fr; } }
    .pill { display:flex; align-items:center; gap:8px; background:#0f1220; border:1px solid #2a3550; padding:6px 10px; border-radius:12px; }
    .swatch { width:12px; height:12px; border-radius:3px; border:1px solid #0006; }

    .dropzone { border: 2px dashed #2a3550; border-radius: 12px; padding: 12px; background:#0f1220; color:#9fb3c8; text-align:center; }
    .dropzone.drag { border-color:#3b82f6; color:#cfe3ff; background:#0f1220; }
    .filelist { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .chip { border:1px solid #2a3550; background:#0b0f1a; padding:4px 8px; border-radius:999px; font-size:12px; color:#cfe3ff; }
  </style>
</head>
<body>
  <div class="container">
    <h1>GPX Multi‑Compare (Time & Distance)</h1>
    <div class="card">
      <div class="controls">
        <div class="group">
          <label for="gpxFiles">Select one or more GPX files (or drag & drop below)</label>
          <input id="gpxFiles" type="file" accept=".gpx,application/gpx+xml" multiple />
          <div id="dropzone" class="dropzone">Drop GPX files here</div>
          <div id="filelist" class="filelist"></div>
        </div>
        <div class="group">
          <label for="smooth">Smoothing window (points)</label>
          <input id="smooth" type="number" min="1" value="5" />
          <label><input type="checkbox" id="showPoints" /> Show points</label>
        </div>
        <div class="group">
          <label>&nbsp;</label>
          <div class="actions">
            <button id="plotBtn" disabled>Parse & Plot</button>
            <button id="clearBtn" disabled>Clear</button>
          </div>
          <div class="small">Each chart overlays all selected activities, time‑aligned at t=0.</div>
        </div>
      </div>

      <div class="meta" id="meta"></div>

      <div class="row">
        <div>
          <h3 class="small" style="margin:8px 0 6px;color:#cfe3ff">Distance over Time (km vs min)</h3>
          <div class="chartWrap"><canvas id="distanceChart"></canvas></div>
        </div>
        <div>
          <h3 class="small" style="margin:8px 0 6px;color:#cfe3ff">Speed over Time (km/h vs min)</h3>
          <div class="chartWrap"><canvas id="speedChart"></canvas></div>
              <div style="margin-top:16px;">
        <h3 class="small" style="margin:8px 0 6px;color:#cfe3ff">Elevation Gain vs Distance (m vs km)</h3>
        <div class="chartWrap"><canvas id="elevChart"></canvas></div>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('gpxFiles');
    const dropzone = document.getElementById('dropzone');
    const filelist = document.getElementById('filelist');
    const plotBtn = document.getElementById('plotBtn');
    const clearBtn = document.getElementById('clearBtn');
    const meta = document.getElementById('meta');
    const showPointsEl = document.getElementById('showPoints');

    let files = [];
    let distanceChart = null, speedChart = null, elevChart = null;
    let buildToken = 0; // guards against overlapping builds

    function refreshFilesView() {
      filelist.innerHTML = '';
      files.forEach(f => filelist.insertAdjacentHTML('beforeend', `<span class="chip">${f.name}</span>`));
      plotBtn.disabled = files.length === 0;
      clearBtn.disabled = files.length === 0;
    }

    fileInput.addEventListener('change', () => {
      files = Array.from(fileInput.files || []);
      refreshFilesView();
    });

    // Drag & drop
    ['dragenter','dragover'].forEach(ev => dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(ev => dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.classList.remove('drag'); }));
    dropzone.addEventListener('drop', e => {
      const dropped = Array.from(e.dataTransfer.files || []).filter(f => /\.gpx$/i.test(f.name));
      if (dropped.length) { files = files.concat(dropped); refreshFilesView(); }
    });

    // GPX parsing
    async function parseGPX(file) {
      const text = await file.text();
      const xml = new DOMParser().parseFromString(text, 'application/xml');
      const trkpts = [...xml.getElementsByTagName('trkpt')];
      const pts = trkpts.map(pt => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        const eleEl = pt.getElementsByTagName('ele')[0];
        const timeEl = pt.getElementsByTagName('time')[0];
        const ele = eleEl ? parseFloat(eleEl.textContent) : null;
        const time = timeEl ? new Date(timeEl.textContent.trim()) : null;
        return { lat, lon, ele, time };
      }).filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
      return pts;
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1); const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function smoothArray(arr, windowSize) {
      if (windowSize <= 1) return arr.slice();
      const half = Math.floor(windowSize / 2);
      return arr.map((_, i) => {
        const start = Math.max(0, i - half), end = Math.min(arr.length - 1, i + half);
        const slice = arr.slice(start, end + 1).filter(Number.isFinite);
        const sum = slice.reduce((a, b) => a + b, 0);
        return slice.length ? sum / slice.length : NaN;
      });
    }

    function computeSeries(pts, smoothWin = 1) {
      if (!pts.length) return null;

      const hasTime = pts.every(p => p.time instanceof Date && !isNaN(p.time));
      const times = hasTime ? pts.map(p => (p.time - pts[0].time) / 60000) : pts.map((_, i) => i / 60);

      // cumulative distance (m)
      const dists = [0];
      for (let i = 1; i < pts.length; i++) {
        dists[i] = dists[i - 1] + haversine(pts[i - 1].lat, pts[i - 1].lon, pts[i].lat, pts[i].lon);
      }
      const distKm = dists.map(m => m / 1000);

      // instant speed (km/h)
      const speed = [NaN];
      for (let i = 1; i < pts.length; i++) {
        const dtMin = times[i] - times[i - 1];
        const ddKm  = (dists[i] - dists[i - 1]) / 1000;
        speed.push(dtMin > 0 ? (ddKm / (dtMin / 60)) : NaN);
      }

      // elevation arrays → smooth → gain/loss vs start
      const eleRaw   = pts.map(p => Number.isFinite(p.ele) ? p.ele : NaN);
      const eleSm    = smoothArray(eleRaw, smoothWin);
      const firstEle = eleSm.find(Number.isFinite);
      const eleGain  = eleSm.map(e => (Number.isFinite(e) && Number.isFinite(firstEle)) ? (e - firstEle) : NaN);

      return { tMin: times, distKm, speedKmh: smoothArray(speed, smoothWin), eleGain };
    }


    // Simple distinct color generator
    function colorAt(idx, total) {
      const h = (idx * (360 / Math.max(6, total))) % 360; // spread hues
      return `hsl(${h} 90% 60%)`;
    }

    function makeChart(ctx, datasets, xTitle, yTitle, showPoints) {
      return new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false, // we control height via wrapper
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { position: 'top' },
            tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.formattedValue}` } }
          },
          scales: {
            x: { type: 'linear', title: { display: true, text: xTitle }, ticks: { autoSkip: true } },
            y: { title: { display: true, text: yTitle }, beginAtZero: false }
          },
          elements: { point: { radius: showPoints ? 2 : 0 } }
        }
      });
    }

    function updateMeta(statsByFile) {
      meta.innerHTML = '';
      statsByFile.forEach(({ name, color, stats }) => {
        const dist = stats.distKm.at(-1)?.toFixed(2) ?? '0.00';
        const time = stats.tMin.at(-1)?.toFixed(1) ?? '0.0';
        meta.insertAdjacentHTML('beforeend', `<div class="pill"><span class="swatch" style="background:${color}"></span><strong style="color:#cfe3ff">${name}</strong> · ${dist} km in ${time} min</div>`);
      });
    }

    async function buildCharts() {
      const token = ++buildToken; // invalidate any previous build
      const smoothWin = Math.max(1, parseInt(document.getElementById('smooth').value || '1', 10));
      const showPoints = !!showPointsEl.checked;
      if (!files.length) return;
      plotBtn.disabled = true;

      try {
        const parsed = await Promise.all(files.map(parseGPX));
        if (token !== buildToken) return; // a newer build started

        const stats = parsed.map(p => computeSeries(p, smoothWin));
        const statsByFile = files.map((f, i) => ({ name: f.name, color: colorAt(i, files.length), stats: stats[i] }))
                                 .filter(x => x.stats); // drop empty/invalid
        if (!statsByFile.length) return;

        updateMeta(statsByFile);

        const distDatasets = statsByFile.map(({ name, color, stats }) => ({
          label: name,
          data: stats.tMin.map((t, i) => ({ x: t, y: stats.distKm[i] })),
          borderColor: color,
          backgroundColor: color,
          borderWidth: 2,
          tension: 0.15,
          pointRadius: showPoints ? 2 : 0
        }));

        const speedDatasets = statsByFile.map(({ name, color, stats }) => ({
          label: name,
          data: stats.tMin.map((t, i) => ({ x: t, y: stats.speedKmh[i] })),
          borderColor: color,
          backgroundColor: color,
          borderWidth: 2,
          tension: 0.15,
          pointRadius: showPoints ? 2 : 0
        }));

        const elevDatasets = statsByFile.map(({ name, color, stats }) => ({
          label: name,
          data: stats.distKm.map((d, i) => ({ x: d, y: stats.eleGain[i] })),
          borderColor: color,
          backgroundColor: color,
          borderWidth: 2,
          tension: 0.15,
          pointRadius: showPoints ? 2 : 0
        }));


        if (distanceChart) { distanceChart.destroy(); distanceChart = null; }
      if (speedChart) { speedChart.destroy(); speedChart = null; }
      if (elevChart) { elevChart.destroy(); elevChart = null; }
        if (elevChart) { elevChart.destroy(); elevChart = null; }

        distanceChart = makeChart(document.getElementById('distanceChart'), distDatasets, 'Time (min from start)', 'Distance (km)', showPoints);
        speedChart = makeChart(document.getElementById('speedChart'), speedDatasets, 'Time (min from start)', 'Speed (km/h)', showPoints);
        elevChart = makeChart(document.getElementById('elevChart'), elevDatasets, 'Distance (km)', 'Elevation Gain from Start (m)', showPoints);
      } finally {
        plotBtn.disabled = files.length === 0; // re-enable unless no files
      }
    }

    plotBtn.addEventListener('click', buildCharts);

    clearBtn.addEventListener('click', () => {
      files = []; fileInput.value = ''; refreshFilesView(); meta.innerHTML = '';
      if (distanceChart) { distanceChart.destroy(); distanceChart = null; }
      if (speedChart) { speedChart.destroy(); speedChart = null; }
      if (elevChart) { elevChart.destroy(); elevChart = null; }
      ++buildToken; // cancel any in-flight build
    });
  </script>
</body>
</html>
